
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Cwby333/user-microservice/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/Cwby333/user-microservice/internal/adapters/repository/postgres/defferedTasks.go (0.0%)</option>
				
				<option value="file2">github.com/Cwby333/user-microservice/internal/adapters/repository/postgres/dto.go (0.0%)</option>
				
				<option value="file3">github.com/Cwby333/user-microservice/internal/adapters/repository/postgres/init.go (0.0%)</option>
				
				<option value="file4">github.com/Cwby333/user-microservice/internal/adapters/repository/postgres/users.go (0.0%)</option>
				
				<option value="file5">github.com/Cwby333/user-microservice/internal/adapters/tokenStorage/redis/init.go (0.0%)</option>
				
				<option value="file6">github.com/Cwby333/user-microservice/internal/adapters/tokenStorage/redis/tokens.go (0.0%)</option>
				
				<option value="file7">github.com/Cwby333/user-microservice/internal/adapters/tokenStorage/redis/users.go (0.0%)</option>
				
				<option value="file8">github.com/Cwby333/user-microservice/internal/adapters/transport/http/lib/validate.go (0.0%)</option>
				
				<option value="file9">github.com/Cwby333/user-microservice/internal/adapters/transport/http/lib/validateJwt.go (83.3%)</option>
				
				<option value="file10">github.com/Cwby333/user-microservice/internal/adapters/transport/http/middleware/jwt.go (61.7%)</option>
				
				<option value="file11">github.com/Cwby333/user-microservice/internal/adapters/transport/http/middleware/logging.go (100.0%)</option>
				
				<option value="file12">github.com/Cwby333/user-microservice/internal/adapters/transport/http/middleware/recover.go (0.0%)</option>
				
				<option value="file13">github.com/Cwby333/user-microservice/internal/adapters/transport/http/server/server.go (0.0%)</option>
				
				<option value="file14">github.com/Cwby333/user-microservice/internal/adapters/transport/http/userRouter/dto.go (100.0%)</option>
				
				<option value="file15">github.com/Cwby333/user-microservice/internal/adapters/transport/http/userRouter/router.go (58.3%)</option>
				
				<option value="file16">github.com/Cwby333/user-microservice/internal/adapters/transport/http/userRouter/userRouterMocks/mocks.go (0.0%)</option>
				
				<option value="file17">github.com/Cwby333/user-microservice/internal/config/config.go (0.0%)</option>
				
				<option value="file18">github.com/Cwby333/user-microservice/internal/migrations/migrations.go (0.0%)</option>
				
				<option value="file19">github.com/Cwby333/user-microservice/internal/service/userService/mock_userService/mocks.go (0.0%)</option>
				
				<option value="file20">github.com/Cwby333/user-microservice/internal/service/userService/service.go (73.1%)</option>
				
				<option value="file21">github.com/Cwby333/user-microservice/internal/service/userService/tokens.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/Cwby333/user-microservice/internal/adapters/repository/postgres"
        "github.com/Cwby333/user-microservice/internal/adapters/tokenStorage/redis"
        "github.com/Cwby333/user-microservice/internal/adapters/transport/http/server"
        userrouter "github.com/Cwby333/user-microservice/internal/adapters/transport/http/userRouter"
        "github.com/Cwby333/user-microservice/internal/config"
        "github.com/Cwby333/user-microservice/internal/migrations"
        userservice "github.com/Cwby333/user-microservice/internal/service/userService"

        "golang.org/x/sync/errgroup"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        signalChan := make(chan os.Signal, 3)
        signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM, os.Kill)

        logger := initLogger()

        go func() </span><span class="cov0" title="0">{
                sig := &lt;-signalChan

                logger.Error("received signal", slog.String("signal", sig.String()))
                cancel()
        }</span>()

        <span class="cov0" title="0">cfg := config.MustLoad()

        pgCfg := postgres.Config{
                Host:     cfg.DB.Host,
                Port:     cfg.DB.Port,
                User:     cfg.DB.User,
                Password: cfg.DB.Password,
                DB:       cfg.DB.DB,
                MaxConns: cfg.DB.MaxConns,
                MinConns: cfg.DB.MinConns,
        }

        pg, err := postgres.New(ctx, pgCfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("postgres connect", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">connStr := fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable", cfg.DB.User, cfg.DB.Password, cfg.DB.Host, cfg.DB.Port, cfg.DB.DB)

        err = migrations.Migrate(connStr)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error(err.Error())
                return
        }</span>

        <span class="cov0" title="0">cfgRedis := redis.Config{
                Host:     cfg.Redis.Host,
                Port:     cfg.Redis.Port,
                Username: cfg.Redis.Username,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        }

        redis, err := redis.New(ctx, cfgRedis)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("redis connect", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">cfgJWT := userservice.JWTConfig{
                SecretKey:      cfg.JWT.SecretKey,
                Issuer:         cfg.JWT.Issuer,
                AccessExpired:  cfg.JWT.JWTAccess.Expired,
                RefreshExpired: cfg.JWT.JWTRefresh.Expired,
        }
        userService := userservice.New(pg, pg, redis, redis, cfgJWT)

        userRouter := userrouter.New(userService, userService, logger)
        userRouter.Run()

        cfgServer := server.Config{
                Address:         cfg.Server.Address,
                IdleTimeout:     cfg.Server.IdleTimeout,
                ShutdownTimeout: cfg.Server.ShutdownTimeout,
        }

        serv := server.New(cfgServer, userRouter.Mux)

        g, gCtx := errgroup.WithContext(ctx)

        g.Go(func() error </span><span class="cov0" title="0">{
                logger.Info("server start", slog.String("address", cfg.Server.Address))
                return serv.Server.ListenAndServe()
        }</span>)

        <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{
                &lt;-gCtx.Done()
                logger.Info("start shutdown")

                ctxShutdown, canc := context.WithTimeout(context.Background(), cfg.Server.ShutdownTimeout)
                defer canc()

                return serv.Server.Shutdown(ctxShutdown)
        }</span>)

        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                logger.Info("server stopped", slog.String("error", err.Error()))
        }</span>
}

func initLogger() *slog.Logger <span class="cov0" title="0">{
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        }))

        slog.SetDefault(logger)

        return logger
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/Cwby333/user-microservice/internal/models"
)

func (pg Postgres) Create(ctx context.Context, task models.DefferedTask) error <span class="cov0" title="0">{
        const op = "./internal/adapter/repository/postgres/defferedTasks.go.Create"
        const query = `INSERT INTO deffered_tasks(topic, data, created_at) VALUES($1, $2, $3)`

        _, err := pg.pool.Exec(ctx, query, task.Topic, task.Data, task.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package postgres

import (
        "github.com/Cwby333/user-microservice/internal/models"
)

type UserDTO struct {
        ID       string `db:"id"`
        Username string `db:"username"`
        Password string `db:"password"`
        Role     string `db:"role"`
        Email    string `db:"email"`
}

func ToUserDTO(u models.User) UserDTO <span class="cov0" title="0">{
        userDTO := UserDTO{
                ID:       u.ID,
                Username: u.Username,
                Role:     u.Role,
                Password: u.Password,
                Email:    u.Email,
        }

        return userDTO
}</span>

func DTOToUser(u UserDTO) models.User <span class="cov0" title="0">{
        user := models.User{
                ID:       u.ID,
                Username: u.Username,
                Role:     u.Role,
                Password: u.Password,
                Email:    u.Email,
        }

        return user
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/jackc/pgx/v5/pgxpool"
)

type Postgres struct {
        pool *pgxpool.Pool
}

type PostgresTest struct {
        pg Postgres
        isUp bool
}

type Config struct {
        Host     string
        Port     uint16
        User     string
        Password string
        DB       string
        MaxConns int
        MinConns int
}

func New(ctx context.Context, cfg Config) (Postgres, error) {
        const op = "./internal/adapters/postgres/init.go"
        
        dsn := fmt.Sprintf(
                "postgres://%s:%s@%s:%d/%s?sslmode=disable&amp;pool_max_conns=%d&amp;pool_min_conns=%d",
                cfg.User,
                cfg.Password,
                cfg.Host,
                cfg.Port,
                cfg.DB,
                cfg.MaxConns,</span><span class="cov0" title="0">
                cfg.MinConns,
        )</span>

        <span class="cov0" title="0">poolCfg, err := pgxpool.ParseConfig(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return Postgres{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">pgxpool, err := pgxpool.NewWithConfig(ctx, poolCfg)
        if err != nil </span><span class="cov0" title="0">{
                return Postgres{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">err = pgxpool.Ping(ctx)
        if err != nil {
                retur</span>n Postgres{}, fmt.Errorf("%s: %w", op, err)
        }

        return Postgres{
                pool: pgxpool,
        </span>}, nil
}

func (p Postgres) Close() {
        p.pool.Close()
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "errors"
        "fmt"
        "strings"

        allerrors "github.com/Cwby333/user-microservice/internal/allErrors"
        "github.com/Cwby333/user-microservice/internal/models"
        "github.com/jackc/pgx/v5"
)

func (pg Postgres) CreateUser(ctx context.Context, user models.User) (models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.CreateUser"
        const query = `INSERT INTO users(username, password, email, role) VALUES($1, $2, $3, $4)`
        const query2 = `SELECT id FROM users WHERE username = $1`

        userDTO := ToUserDTO(user)

        _, err := pg.pool.Exec(ctx, query,
                userDTO.Username,
                userDTO.Password,
                userDTO.Email,
                userDTO.Role,
        )
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "users_username_key") </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrUsernameExists)
                }</span>

                <span class="cov0" title="0">if strings.Contains(err.Error(), "users_email_key") </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrEmailExists)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">rows, err := pg.pool.Query(ctx, query2, user.Username)

        var id string
        for rows.Next() </span><span class="cov0" title="0">{
                err := rows.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, err)
                }</span>
        }

        <span class="cov0" title="0">user.ID = id

        return user, nil</span>
}

func (pg Postgres) GetUserByID(ctx context.Context, ID string) (models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.GetUserByUsername"
        const query = `SELECT id, username, password, email, role FROM users WHERE id = $1`

        rows, err := pg.pool.Query(ctx, query, ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrUserNotExists)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">DTO, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[UserDTO])
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrUserNotExists)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">user := DTOToUser(DTO)

        return user, nil</span>
}

func (pg Postgres) GetUserByUsername(ctx context.Context, username string) (models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.GetUserByUsername"
        const query = `SELECT id, username, password, email, role FROM users WHERE username = $1`

        rows, err := pg.pool.Query(ctx, query, username)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrUserNotExists)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">DTO, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[UserDTO])
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrUserNotExists)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">user := DTOToUser(DTO)

        return user, nil</span>
}

func (pg Postgres) GetAllUsers(ctx context.Context) ([]models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.GetUserByUsername"
        const query = `SELECT id, username, password, email, role FROM users`

        rows, err := pg.pool.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">sliceDTO, err := pgx.CollectRows(rows, pgx.RowToStructByName[UserDTO])
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "no rows in result set" </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("%s: %w", op, err)</span>
        }

        <span class="cov0" title="0">sliceUsers := make([]models.User, 0, len(sliceDTO))

        for i := range sliceDTO </span><span class="cov0" title="0">{
                sliceUsers = append(sliceUsers, DTOToUser(sliceDTO[i]))
        }</span>

        <span class="cov0" title="0">return sliceUsers, nil</span>
}

func (pg Postgres) DeleteUserByID(ctx context.Context, ID string) error <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.DeleteUserByID"
        const query = `DELETE FROM users WHERE id = $1`

        rows, err := pg.pool.Query(ctx, query, ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov0" title="0">rows.Close()

        return nil</span>
}

func (pg Postgres) UpdateUserByID(ctx context.Context, ID string, newUserInfo models.User) (models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/postgres/users.go.UpdateUserByID"
        const query = `UPDATE users SET username = $1, role = $2, password = $3, email = $4 WHERE id = $5`

        rows, err := pg.pool.Query(ctx, query,
                newUserInfo.Username,
                newUserInfo.Role,
                newUserInfo.Password,
                newUserInfo.Email,
                ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return newUserInfo, nil
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, err)</span>
        }
        <span class="cov0" title="0">rows.Close()

        return newUserInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package redis

import (
        "context"
        "fmt"
        "strconv"

        "github.com/redis/go-redis/v9"
)

type Redis struct {
        client *redis.Client
}

type Config struct {
        Host     string
        Port     int
        Username string
        Password string
        DB       int
}

func New(ctx context.Context, cfg Config) (Redis, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/tokenStorage/redis/init.go.New"

        client := redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Host + ":" + strconv.Itoa(cfg.Port),
                Username: cfg.Username,
                Password: cfg.Password,
                DB:       cfg.DB,
        })

        tag := client.Ping(ctx)
        if tag.Err() != nil </span><span class="cov0" title="0">{
                return Redis{}, fmt.Errorf("%s: %w", op, tag.Err())
        }</span>

        <span class="cov0" title="0">return Redis{
                client: client,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package redis

import (
        "context"
        "fmt"
        "time"
)

const (
        refreshStorage = "refresh:"
)

func (r Redis) InvalidRefresh(ctx context.Context, tokenID string, unixTime time.Time) error <span class="cov0" title="0">{
        const op = "./internal/adapters/tokenStorage/redis/tokens.go.InvalidRefresh"

        cmd := r.client.HSet(ctx, refreshStorage, tokenID, "")
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, cmd.Err())
        }</span>

        <span class="cov0" title="0">cmd2 := r.client.HExpireAt(ctx, refreshStorage, unixTime, tokenID)
        if cmd2.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, cmd.Err())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package redis

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        allerrors "github.com/Cwby333/user-microservice/internal/allErrors"
        "github.com/Cwby333/user-microservice/internal/models"

        gojson "github.com/goccy/go-json"
        "github.com/redis/go-redis/v9"
)

const (
        usersStorage = "users:"
)

type DTO struct {
        ID string `json:"id"`
        Username string `json:"username"`
        Password string `json:"password"`
        Email string `json:"email"`
        Role string `json:"role"`
}

func (r Redis) Set(ctx context.Context, userID string, user models.User) error <span class="cov0" title="0">{
        const op = "./internal/adapters/tokenStorage/redis/users.go.Set"

        dto := DTO{
                ID: user.ID,
                Username: user.Username,
                Password: user.Password,
                Email: user.Email,
                Role: user.Role,
        }
        data, err := gojson.Marshal(dto)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("user cache, gojson marshal", slog.String("error", err.Error()))
                
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">cmd := r.client.HSet(ctx, usersStorage, userID, data)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, cmd.Err())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r Redis) Get(ctx context.Context, userID string) (models.User, error) <span class="cov0" title="0">{
        const op = "./internal/adapters/tokenStorage/redis/users.go.Get"

        cmd := r.client.HGet(ctx, usersStorage, userID)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                if errors.Is(cmd.Err(), redis.Nil) </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrNotFoundInCache)
                }</span>

                <span class="cov0" title="0">return models.User{}, fmt.Errorf("%s: %w", op, cmd.Err())</span>
        }

        <span class="cov0" title="0">res, err := cmd.Result()
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("cmd result", slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">var dto DTO
        err = gojson.Unmarshal([]byte(res), &amp;dto)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson unmarshal", slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">user := models.User{
                ID: dto.ID,
                Username: dto.Username,
                Password: dto.Password,
                Email: dto.Email,
                Role: dto.Role,
        }

        return user, nil</span>
}

func (r Redis) Delete(ctx context.Context, userID string) error <span class="cov0" title="0">{
        const op = "./internal/adapters/tokenStorage/redis/users.go.Delete"

        cmd := r.client.HDel(ctx, usersStorage, userID)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, cmd.Err())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package lib

import (
        "fmt"

        "github.com/go-playground/validator/v10"
)

func Validate(errors validator.ValidationErrors) []string <span class="cov0" title="0">{
        out := make([]string, 0, len(errors))

        for _, err := range errors </span><span class="cov0" title="0">{
                switch err.ActualTag() </span>{
                case "required":<span class="cov0" title="0">
                        str := fmt.Sprintf("field %s is required", err.Field())

                        out = append(out, str)</span>
                }
        }

        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package lib

import (
        "errors"
        "fmt"
        "os"

        "github.com/golang-jwt/jwt/v5"
)

func ValidateJWT(token string) (jwt.MapClaims, error) <span class="cov8" title="1">{
        const op = "./internal/adapters/transport/http/lib/validateJwt"
        secretKey := os.Getenv("JWT_SECRET_KEY")

        t, err := jwt.ParseWithClaims(token, jwt.MapClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(secretKey), nil
        }</span>, jwt.WithIssuer(os.Getenv("JWT_ISSUER")),
                jwt.WithExpirationRequired(),
        )

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return jwt.MapClaims{}, fmt.Errorf("%s: %w", op, err)
        }</span>
        
        <span class="cov8" title="1">if !t.Valid </span><span class="cov0" title="0">{
                return jwt.MapClaims{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">claims, ok := t.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return jwt.MapClaims{}, fmt.Errorf("%s: %w", op, errors.New("wrong claims type"))
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
        "os"
        "strings"

        "github.com/Cwby333/user-microservice/internal/adapters/transport/http/lib"
        gojson "github.com/goccy/go-json"
        "github.com/golang-jwt/jwt/v5"
)

func AccessJWT(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                token := r.Header.Get("Authorization")
                token = strings.TrimPrefix(token, "Bearer ")

                if token == "" </span><span class="cov8" title="1">{
                        slog.Info("missing auth token")

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "missing auth token",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "missing auth token", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">secretKey := os.Getenv("JWT_SECRET_KEY")

                t, err := jwt.ParseWithClaims(token, jwt.MapClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return []byte(secretKey), nil
                }</span>, jwt.WithIssuer(os.Getenv("JWT_ISSUER")),
                        jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
                        jwt.WithExpirationRequired(),
                )

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        slog.Info("jwt parse", slog.String("error", err.Error()))

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "unauthorized",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">if !t.Valid </span><span class="cov0" title="0">{
                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "unauthorized",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">claims, ok := t.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "serve error", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">typeToken, ok := claims["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "serve error", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">if typeToken != "access" </span><span class="cov8" title="1">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "wrong token type",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "wrong token type", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">ctx := r.Context()
                ctx = context.WithValue(ctx, "claims", claims)
                r = r.WithContext(ctx)

                slog.Info("success jwt-access middleware")

                next.ServeHTTP(w, r)</span>
        })
}

func RefreshJWT(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                //        TODO: Maybe change
                //        token := r.Header.Get("Authorization")
                //        token = strings.TrimPrefix(token, "Bearer ")
                //        TO Cookie["jwt-refresh"]

                token := r.Header.Get("Authorization")
                token = strings.TrimPrefix(token, "Bearer ")

                if token == "" </span><span class="cov8" title="1">{
                        slog.Info("missing refresh token")

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "missing auth token",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "missing auth token", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">secretKey := os.Getenv("JWT_SECRET_KEY")

                t, err := jwt.ParseWithClaims(token, jwt.MapClaims{}, func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return []byte(secretKey), nil
                }</span>, jwt.WithIssuer(os.Getenv("JWT_ISSUER")),
                        jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Name}),
                        jwt.WithExpirationRequired(),
                )

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        slog.Info("jwt parse", slog.String("error", err.Error()))

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "unauthorized",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">if !t.Valid </span><span class="cov0" title="0">{
                        slog.Info("jwt invalid")

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "unauthorized",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">claims, ok := t.Claims.(jwt.MapClaims)
                if !ok </span><span class="cov0" title="0">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "serve error", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">typeToken, ok := claims["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "serve error", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">if typeToken != "refresh" </span><span class="cov8" title="1">{
                        resp := lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "wrong token type",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "wrong token type", http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                        return</span>
                }

                <span class="cov8" title="1">ctx := r.Context()
                ctx = context.WithValue(ctx, "claims", claims)
                r = r.WithContext(ctx)

                slog.Info("success jwt-refresh middleware")

                next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "fmt"
        "log/slog"
        "net/http"
)

type Request struct {
        RemoteAddr    string
        Host          string
        Method        string
        URL           string
        ContentLength int64
}

func Logging(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                req := Request{
                        RemoteAddr:    r.RemoteAddr,
                        Host:          r.Host,
                        Method:        r.Method,
                        URL:           r.RequestURI,
                        ContentLength: r.ContentLength,
                }

                str := fmt.Sprintf("remoteAddr: %s, host: %s, method: %s, url: %s, contentLength: %d", req.RemoteAddr, req.Host, req.Method, req.URL, req.ContentLength)

                slog.Info("logging request", slog.String("request", str))

                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        gojson "github.com/goccy/go-json"
        "log/slog"
        "net/http"

        "github.com/Cwby333/user-microservice/internal/adapters/transport/http/lib"
)

func Recover(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        r := recover()
                        if r != nil </span><span class="cov0" title="0">{
                                slog.Info("recover middleware", slog.Any("recover", r))

                                resp := lib.Response{
                                        StatusCode: http.StatusInternalServerError,
                                        Message:    "server error",
                                }
                                data, err := gojson.Marshal(resp)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.Info("recover middle json marshal", slog.String("error", err.Error()))

                                        http.Error(w, "server error", http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                                return</span>
                        }
                }()

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "fmt"
        "net/http"
        "time"
)

type Server struct {
        Server *http.Server
}

type Config struct {
        Address         string
        IdleTimeout     time.Duration
        ShutdownTimeout time.Duration
}

func New(cfg Config, mux http.Handler) *Server <span class="cov0" title="0">{
        server := &amp;http.Server{
                Addr:        cfg.Address,
                IdleTimeout: cfg.IdleTimeout,
                Handler:     mux,
        }
        fmt.Println(server)

        return &amp;Server{
                Server: server,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package userrouter

import "github.com/Cwby333/user-microservice/internal/models"

//easyjson:json
type UserDTO struct {
        ID       string `json:"id" omitempty:"true"`
        Username string `json:"username" omitempty:"true"`
        Password string `json:"password" omitempty:"true"`
        Email    string `json:"email" omitempty:"true"`
        Role     string `json:"role" omitempty:"true"`
}

func UserToDTO(u models.User) UserDTO <span class="cov8" title="1">{
        DTO := UserDTO{
                ID:       u.ID,
                Username: u.Username,
                Password: u.Password,
                Email:    u.Email,
                Role:     u.Role,
        }

        return DTO
}</span>

func DTOToUser(u UserDTO) models.User <span class="cov8" title="1">{
        user := models.User{
                ID:       u.ID,
                Username: u.Username,
                Password: u.Password,
                Email:    u.Email,
                Role:     u.Role,
        }

        return user
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package userrouter

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/Cwby333/user-microservice/internal/adapters/transport/http/lib"
        "github.com/Cwby333/user-microservice/internal/adapters/transport/http/middleware"
        allerrors "github.com/Cwby333/user-microservice/internal/allErrors"
        "github.com/Cwby333/user-microservice/internal/models"

        "github.com/go-playground/validator/v10"
        gojson "github.com/goccy/go-json"
        "github.com/golang-jwt/jwt/v5"
)

type UserService interface {
        Register(ctx context.Context, user models.User) (models.User, error)
        Login(ctx context.Context, user models.User) (models.JWTAccess, models.JWTRefresh, error)
        Logout(ctx context.Context, tokenID string, unixTimeExpired time.Time) error

        FindUserByID(ctx context.Context, ID string) (models.User, error)
        GetAllUsers(ctx context.Context) ([]models.User, error)

        DeleteUser(ctx context.Context, ID string) error

        UpdateUser(ctx context.Context, ID string, newUserInfo models.User) (models.User, error)

        CreateTokens(ctx context.Context, user models.User) (access models.JWTAccess, refresh models.JWTRefresh, err error)
}

type DefferedTaskService interface {
        ActionWithSong(ctx context.Context, task models.DefferedTask) error
}

type Router struct {
        Mux         *http.ServeMux
        userService UserService
        taskService DefferedTaskService
        logger      *slog.Logger
        validator   *validator.Validate
}

func New(userService UserService, taskService DefferedTaskService, logger *slog.Logger) Router <span class="cov8" title="1">{
        return Router{
                Mux:         http.NewServeMux(),
                userService: userService,
                taskService: taskService,
                logger:      logger,
                validator:   validator.New(validator.WithRequiredStructEnabled()),
        }
}</span>

func (r *Router) Handle(pattern string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) <span class="cov0" title="0">{
        for i := 0; i &lt; len(middlewares); i++ </span><span class="cov0" title="0">{
                handler = middlewares[i](handler)
        }</span>

        <span class="cov0" title="0">r.Mux.Handle(pattern, handler)</span>
}

func (router *Router) Run() <span class="cov0" title="0">{
        router.Handle("POST /user/register", http.HandlerFunc(router.Register), middleware.Recover, middleware.Logging)
        router.Handle("POST /user/login", http.HandlerFunc(router.Login), middleware.Recover, middleware.Logging)
        router.Handle("POST /user/logout", http.HandlerFunc(router.Logout), middleware.Recover, middleware.Logging)
        router.Handle("POST /user/refresh", http.HandlerFunc(router.RefreshTokens), middleware.Recover, middleware.Logging, middleware.RefreshJWT)

        router.Handle("GET /user/get", http.HandlerFunc(router.GetUserByID), middleware.Recover, middleware.Logging, middleware.AccessJWT)
        router.Handle("GET /user/all", http.HandlerFunc(router.GetAllUsers), middleware.Recover, middleware.Logging, middleware.AccessJWT)

        router.Handle("DELETE /user/delete", http.HandlerFunc(router.DeleteUser), middleware.Recover, middleware.Logging, middleware.AccessJWT)
        router.Handle("PUT /user/update", http.HandlerFunc(router.UpdateUser), middleware.Recover, middleware.Logging, middleware.AccessJWT)

        router.Handle("POST /user/track/favorite", http.HandlerFunc(router.ActionWithSong), middleware.Recover, middleware.Logging, middleware.AccessJWT)
        router.Handle("DELETE /user/track/favorite", http.HandlerFunc(router.ActionWithSong), middleware.Recover, middleware.Logging, middleware.AccessJWT)
}</span>

type RegisterRequest struct {
        Username string `json:"username" validate:"required"`
        Email    string `json:"email" validate:"required"`
        Password string `json:"password" validate:"required"`
}

type RegisterResponse struct {
        Response lib.Response
        Username string `json:"username" omitempty:"true"`
        Email    string `json:"email" omitempty:"true"`
        ID       string `json:"id" omitempty:"true"`
}

func (router *Router) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        data, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("registerHandler read body", slog.String("error", err.Error()))

                resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err = gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }
        <span class="cov8" title="1">r.Body.Close()

        var req RegisterRequest
        err = gojson.Unmarshal(data, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson unmarshal", slog.String("error", err.Error()))

                resp := lib.Response{
                        StatusCode: http.StatusInternalServerError,
                        Message:    "server error",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">err = router.validator.Struct(req)
        if err != nil </span><span class="cov8" title="1">{
                errorsValidate := err.(validator.ValidationErrors)

                errors := lib.Validate(errorsValidate)

                errForResp := ""
                for i := range errors </span><span class="cov8" title="1">{
                        errForResp += errors[i] + " "
                }</span>
                <span class="cov8" title="1">errForResp = strings.TrimSpace(errForResp)

                slog.Info("validation", slog.String("error", errForResp))

                resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusBadRequest,
                                Message:    errForResp,
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("bad request: %s", errForResp), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">userDTO := UserDTO{
                Username: req.Username,
                Email:    req.Email,
                Password: req.Password,
        }

        user := DTOToUser(userDTO)

        // isAdmin := r.Context().Value("isAdmin").(bool)
        // if isAdmin {
        //         user.Role = "admin"
        // }

        user, err = router.userService.Register(r.Context(), user)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("register handler", slog.String("error", err.Error()))

                if errors.Is(err, allerrors.ErrUsernameExists) </span><span class="cov8" title="1">{
                        resp := RegisterResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "username already exists",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "username already exists", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">if errors.Is(err, allerrors.ErrEmailExists) </span><span class="cov8" title="1">{
                        resp := RegisterResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "email already exists",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "email already exists", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">if errors.Is(err, allerrors.ErrPasswordSmall) </span><span class="cov8" title="1">{
                        resp := RegisterResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "password to small",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "password to small", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">if errors.Is(err, allerrors.ErrPasswordBig) </span><span class="cov8" title="1">{
                        resp := RegisterResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "password to big",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "password to big", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">userDTO = UserToDTO(user)

        response := RegisterResponse{
                Response: lib.Response{
                        StatusCode: http.StatusOK,
                        Message:    "success register",
                },
                Username: userDTO.Username,
                Email:    userDTO.Email,
                ID:       userDTO.ID,
        }
        data, err = gojson.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson unmarshall", slog.String("error", err.Error()))

                strResponse := fmt.Sprintf("success register, username: %s email: %s ID: %s", userDTO.Username, userDTO.Email, userDTO.ID)
                w.Write([]byte(strResponse))
                return
        }</span>

        <span class="cov8" title="1">w.Write(data)
        return</span>
}

type LoginRequest struct {
        Username string `json:"username" validate:"required"`
        Password string `json:"password" validate:"required"`
}

type LoginResponse struct {
        Response lib.Response `json:"response"`
}

func (router *Router) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req LoginRequest

        data, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("registerHandler read body", slog.String("error", err.Error()))

                resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "serve error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }
        <span class="cov8" title="1">r.Body.Close()

        err = gojson.Unmarshal(data, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson unmarshal", slog.String("error", err.Error()))

                resp := lib.Response{
                        StatusCode: http.StatusInternalServerError,
                        Message:    "server error",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">err = router.validator.Struct(req)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("validator error", slog.String("error", err.Error()))

                errorsValidate := err.(validator.ValidationErrors)

                errors := lib.Validate(errorsValidate)

                errForResp := ""
                for i := range errors </span><span class="cov8" title="1">{
                        errForResp += errors[i] + " "
                }</span>

                <span class="cov8" title="1">resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusBadRequest,
                                Message:    errForResp,
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, fmt.Sprintf("bad request: %s", errForResp), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">userDTO := UserDTO{
                Username: req.Username,
                Password: req.Password,
        }

        user := DTOToUser(userDTO)

        access, refresh, err := router.userService.Login(r.Context(), user)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("login handler", slog.String("error", err.Error()))

                if errors.Is(err, allerrors.ErrUserNotExists) </span><span class="cov8" title="1">{
                        slog.Info("wrong username")
                        resp := LoginResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusNotFound,
                                        Message:    "username not found",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "username not found", http.StatusNotFound)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusNotFound)
                        return</span>
                }
                <span class="cov8" title="1">if errors.Is(err, allerrors.ErrWrongPass) </span><span class="cov8" title="1">{
                        resp := LoginResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "wrong password",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "wrong password", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }

                <span class="cov8" title="1">slog.Error("server error")
                resp := LoginResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">resp := LoginResponse{
                Response: lib.Response{
                        StatusCode: http.StatusOK,
                        Message:    "success login",
                },
        }
        data, err = gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                http.SetCookie(w, &amp;http.Cookie{
                        Name:     "jwt-access",
                        Value:    access.Sign,
                        HttpOnly: true,
                        Secure:   true,
                        Expires:  access.ExpiresAt.Time,
                })
                http.SetCookie(w, &amp;http.Cookie{
                        Name:    "jwt-refresh",
                        Value:   refresh.Sign,
                        Secure:  true,
                        Expires: refresh.ExpiresAt.Time,
                        Path:    "/user/refresh",
                })
                http.SetCookie(w, &amp;http.Cookie{
                        Name:    "jwt-refresh-logout",
                        Value:   refresh.Sign,
                        Secure:  true,
                        Expires: refresh.ExpiresAt.Time,
                        Path:    "/user/logout",
                })

                _, err = w.Write([]byte("success login"))
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("response write", slog.String("error", err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">slog.Info("success login")

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "jwt-access",
                Value:    access.Sign,
                HttpOnly: true,
                Secure:   true,
                Expires:  access.ExpiresAt.Time,
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh",
                Value:   refresh.Sign,
                Secure:  true,
                Expires: refresh.ExpiresAt.Time,
                Path:    "/user/refresh",
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh-logout",
                Value:   refresh.Sign,
                Secure:  true,
                Expires: refresh.ExpiresAt.Time,
                Path:    "/user/logout",
        })

        _, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("response write", slog.String("error", err.Error()))
        }</span>

        <span class="cov8" title="1">return</span>
}

// TODO: change get refresh token by logout handler (check login, refreshTokens handlers, in cookie)
// Or remove logic store invalid refresh tokens in redis
func (router *Router) Logout(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        refresh, err := r.Cookie("jwt-refresh-logout")
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("missing refresh token for logout")

                resp := lib.Response{
                        StatusCode: http.StatusUnauthorized,
                        Message:    "unauthorized",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                return</span>
        }

        <span class="cov8" title="1">token := refresh.Value
        claims, err := lib.ValidateJWT(token)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("validate jwt", slog.String("error", err.Error()))

                resp := lib.Response{
                        StatusCode: http.StatusUnauthorized,
                        Message:    "unauthorized",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                return</span>
        }

        <span class="cov8" title="1">jti := claims["jti"].(string)
        _ = jti
        exp := claims["exp"].(float64)
        expiredTime := time.Unix(int64(exp), 0)

        err = router.userService.Logout(r.Context(), jti, expiredTime)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, allerrors.ErrWrongUUID) </span><span class="cov8" title="1">{
                        slog.Info("logout handler", slog.String("error", err.Error()))

                        resp := lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "wrong uuid",
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "wrong uuid", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                        return</span>
                }

                <span class="cov8" title="1">slog.Info("logout handler", slog.String("error", err.Error()))

                resp := lib.Response{
                        StatusCode: http.StatusInternalServerError,
                        Message:    "server error",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "jwt-access",
                Value:    "",
                HttpOnly: true,
                Secure:   true,
                Expires:  time.Now().Add(time.Second * 3),
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh",
                Value:   "",
                Secure:  true,
                HttpOnly: true,
                Expires: time.Now().Add(time.Second * 3),
                Path:    "/user/refresh",
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh-logout",
                Value:   "",
                Secure:  true,
                Expires: time.Now().Add(time.Second * 3),
                Path:    "/user/logout",
        })

        resp := lib.Response{
                StatusCode: http.StatusOK,
                Message:    "success",
        }
        data, err := gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                _, err = w.Write([]byte("success"))
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("response write", slog.String("error", err.Error()))
                }</span>

                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">slog.Info("success logout")

        _, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("response write", slog.String("error", err.Error()))
        }</span>
}

func (router *Router) RefreshTokens(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        claims := r.Context().Value("claims").(jwt.MapClaims)
        userID := claims["sub"].(string)
        role := claims["role"].(string)

        user := models.User{
                ID:   userID,
                Role: role,
        }

        access, refresh, err := router.userService.CreateTokens(r.Context(), user)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("create tokens", slog.String("error", err.Error()))

                resp := lib.Response{
                        StatusCode: http.StatusInternalServerError,
                        Message:    "server error",
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">slog.Info("success refresh")

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "jwt-access",
                Value:    access.Sign,
                HttpOnly: true,
                Secure:   true,
                Expires:  access.ExpiresAt.Time,
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh",
                Value:   refresh.Sign,
                Secure:  true,
                Expires: refresh.ExpiresAt.Time,
                Path:    "/user/refresh",
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh-logout",
                Value:   refresh.Sign,
                Secure:  true,
                Expires: refresh.ExpiresAt.Time,
                Path:    "/user/logout",
        })

        resp := lib.Response{
                StatusCode: http.StatusOK,
                Message:    "success",
        }
        data, err := gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                w.Write([]byte("success"))
                return
        }</span>

        <span class="cov8" title="1">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("response write", slog.String("error", err.Error()))
        }</span>
}

type GetUserByIDResponse struct {
        Response lib.Response `json:"response"`
        Username string       `json:"username" omitempty:"true"`
}

func (router *Router) GetUserByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ID := r.URL.Query().Get("user_id")
        if ID == "" </span><span class="cov8" title="1">{
                slog.Info("getUserByIDHandler", slog.String("error", "missing ID"))

                resp := GetUserByIDResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusBadRequest,
                                Message:    "missing {user_id} in query parameter",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "missing {user_id} in query parameter", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">user, err := router.userService.FindUserByID(r.Context(), ID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("getUserByIdHandler", slog.String("err", err.Error()))

                if errors.Is(err, allerrors.ErrWrongUUID) </span><span class="cov8" title="1">{
                        resp := GetUserByIDResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusBadRequest,
                                        Message:    "wrong user ID",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "wrong user ID", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusBadRequest)
                        return</span>
                }
                <span class="cov8" title="1">if errors.Is(err, allerrors.ErrUserNotExists) </span><span class="cov8" title="1">{
                        resp := GetUserByIDResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusNotFound,
                                        Message:    "user not found",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "user not found", http.StatusNotFound)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusNotFound)
                        return</span>
                }

                <span class="cov8" title="1">resp := GetUserByIDResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">resp := GetUserByIDResponse{
                Response: lib.Response{
                        StatusCode: http.StatusOK,
                        Message:    "success",
                },
                Username: user.Username,
        }
        data, err := gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                strOut := fmt.Sprintf("username: {%s}, ID: {%s}", user.Username, user.ID)
                w.Write([]byte(strOut))
                return
        }</span>

        <span class="cov8" title="1">slog.Info("getUserByIDHandler success")

        _, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("response write", slog.String("error", err.Error()))
        }</span>
}

type GetAllUsersResponse struct {
        Response lib.Response `json:"response"`
        Users    []UserDTO    `json:"users" omitempty:"true"`
}

func (router *Router) GetAllUsers(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        claims := r.Context().Value("claims").(jwt.MapClaims)
        role := claims["role"].(string)

        if role != "admin" </span><span class="cov8" title="1">{
                slog.Info("get all users", slog.String("error", fmt.Sprintf("not a admin, ID: %s", claims["sub"].(string))))

                resp := GetAllUsersResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusUnauthorized,
                                Message:    "unauthorized",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusUnauthorized)
                return</span>
        }

        <span class="cov8" title="1">slice, err := router.userService.GetAllUsers(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("getAllUsersHandler", slog.String("error", err.Error()))

                resp := GetAllUsersResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">sliceDTO := make([]UserDTO, 0, len(slice))
        for i := range slice </span><span class="cov8" title="1">{
                sliceDTO = append(sliceDTO, UserToDTO(slice[i]))
        }</span>

        <span class="cov8" title="1">resp := GetAllUsersResponse{
                Response: lib.Response{
                        StatusCode: http.StatusOK,
                        Message:    "success",
                },
                Users: sliceDTO,
        }
        data, err := gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                strOut := ""
                for i := range sliceDTO </span><span class="cov0" title="0">{
                        str := fmt.Sprintf("ID: {%s}, username: {%s}, email: {%s}, password: {%s}, role: {%s}", sliceDTO[i].ID, sliceDTO[i].Username, sliceDTO[i].Email, sliceDTO[i].Password, sliceDTO[i].Role)

                        strOut += str + " "
                }</span>

                <span class="cov0" title="0">w.Write([]byte(strOut))
                return</span>
        }

        <span class="cov8" title="1">slog.Info("getAllUsersHandler success")

        _, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("response write", slog.String("error", err.Error()))
        }</span>
}

type UpdateUserRequest struct {
        NewUsername string `json:"username"`
        NewEmail    string `json:"email" `
        NewPassword string `json:"password"`
}

type UpdateUserResponse struct {
        Response lib.Response `yaml:"response"`
        Username string       `json:"username" omitempty:"true"`
        Email    string       `json:"email" omitempty:"true"`
        ID       string       `json:"id" omitempty:"true"`
}

func (router *Router) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        claims := r.Context().Value("claims").(jwt.MapClaims)

        var req UpdateUserRequest

        data, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("updateHandler read body", slog.String("error", err.Error()))

                resp := RegisterResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }
        <span class="cov8" title="1">r.Body.Close()

        err = gojson.Unmarshal(data, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson unmarshal", slog.String("error", err.Error()))

                resp := UpdateUserResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">user := models.User{
                ID:       claims["sub"].(string),
                Username: req.NewUsername,
                Email:    req.NewEmail,
                Password: req.NewPassword,
        }

        user, err = router.userService.UpdateUser(r.Context(), user.ID, user)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, allerrors.ErrUserNotExists) </span><span class="cov8" title="1">{
                        slog.Info("updateUser handler: user not exists")

                        resp := UpdateUserResponse{
                                Response: lib.Response{
                                        StatusCode: http.StatusNotFound,
                                        Message:    "user not found",
                                },
                        }
                        data, err := gojson.Marshal(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.Info("gojson marshal", slog.String("error", err.Error()))

                                http.Error(w, "user not found", http.StatusNotFound)
                                return
                        }</span>

                        <span class="cov8" title="1">http.Error(w, string(data), http.StatusNotFound)
                        return</span>
                }

                <span class="cov8" title="1">slog.Info("updateUser handler", slog.String("error", err.Error()))

                resp := UpdateUserResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusNotFound,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshal", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusNotFound)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusNotFound)
                return</span>
        }

        <span class="cov8" title="1">resp := UpdateUserResponse{
                Response: lib.Response{
                        StatusCode: http.StatusOK,
                        Message:    "success",
                },
                Username: user.Username,
                Email:    user.Email,
                ID:       user.ID,
        }
        data, err = gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                w.Write([]byte("success"))
                return
        }</span>

        <span class="cov8" title="1">_, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))
        }</span>
}

func (router *Router) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        claims := r.Context().Value("claims").(jwt.MapClaims)

        userID := claims["sub"].(string)

        err := router.userService.DeleteUser(r.Context(), userID)
        if err != nil </span><span class="cov8" title="1">{
                slog.Info("deleteUser handler", slog.String("error", err.Error()))

                resp := UpdateUserResponse{
                        Response: lib.Response{
                                StatusCode: http.StatusInternalServerError,
                                Message:    "server error",
                        },
                }
                data, err := gojson.Marshal(resp)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Info("gojson marshall", slog.String("error", err.Error()))

                        http.Error(w, "server error", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">http.Error(w, string(data), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov8" title="1">resp := lib.Response{
                StatusCode: http.StatusOK,
                Message:    "success",
        }
        data, err := gojson.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))

                w.Write([]byte("success"))
                return
        }</span>

        <span class="cov8" title="1">http.SetCookie(w, &amp;http.Cookie{
                Name:     "jwt-access",
                Value:    "",
                HttpOnly: true,
                Secure:   true,
                Expires:  time.Now().Add(time.Second * 3),
        })
        http.SetCookie(w, &amp;http.Cookie{
                Name:    "jwt-refresh",
                Value:   "",
                Secure:  true,
                Expires: time.Now().Add(time.Second * 3),
                Path:    "/api/users/refresh",
        })

        _, err = w.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))
        }</span>
}

type SongAction struct {
        Action  string `json:"action"`
        UserID  string `json:"user_id"`
        TrackID string `json:"track_id"`
}

// func (router *Router) ActionWithSong(w http.ResponseWriter, r *http.Request) {
//         claims := r.Context().Value("claims").(jwt.MapClaims)
//         userID := claims["sub"].(string)
//         songID := r.URL.Query().Get("track_id")
//         if songID == "" {
//                 slog.Info("song ID empty")

//                 resp := lib.Response{
//                         StatusCode: http.StatusBadRequest,
//                         Message:    "missing {track_id} parameter",
//                 }
//                 data, err := gojson.Marshal(resp)
//                 if err != nil {
//                         slog.Info("gojson marshal", slog.String("error", err.Error()))

//                         http.Error(w, "missing {track_id} parameter", http.StatusBadRequest)
//                         return
//                 }

//                 http.Error(w, string(data), http.StatusBadRequest)
//         }

//         songAction := SongAction{
//                 UserID: userID,
//         }
//         switch r.Method {
//         case "DELETE":
//                 songAction.Action = "unlike"
//         case "POST":
//                 songAction.Action = "like"
//         }

//         data, err := gojson.Marshal(songAction)
//         if err != nil {
//                 slog.Info("gojson marshal", slog.String("error", err.Error()))

//                 http.Error(w, "server error", http.StatusInternalServerError)
//                 return
//         }

//         task := models.DefferedTask{
//                 Topic:     "songs_actions",
//                 Data:      data,
//                 CreatedAt: time.Now(),
//         }

//         err = router.taskService.ActionWithSong(r.Context(), task)
//         if err != nil {
//                 slog.Info("actionWithSong handler", slog.String("error", err.Error()))

//                 resp := lib.Response{
//                         StatusCode: http.StatusInternalServerError,
//                         Message:    "server error",
//                 }
//                 data, err = gojson.Marshal(resp)
//                 if err != nil {
//                         slog.Info("gojson marshal", slog.String("error", err.Error()))

//                         http.Error(w, "server error", http.StatusInternalServerError)
//                         return
//                 }

//                 http.Error(w, string(data), http.StatusInternalServerError)
//                 return
//         }

//         resp := lib.Response{
//                 StatusCode: http.StatusOK,
//                 Message:    "success",
//         }
//         data, err = gojson.Marshal(resp)
//         if err != nil {
//                 slog.Info("gojson marshal", slog.String("error", err.Error()))

//                 _, err = w.Write([]byte("success"))
//                 if err != nil {
//                         slog.Info("response write", slog.String("error", err.Error()))
//                 }
//                 return
//         }

//                _, err = w.Write(data)
//                if err != nil {
//                        slog.Info("response write", slog.String("error", err.Error()))
//                }
//        }
func (router *Router) ActionWithSong(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // 1)  user_id  JWT
        claims := r.Context().Value("claims").(jwt.MapClaims)
        userID := claims["sub"].(string)

        // 2)  track_id  query-
        songID := r.URL.Query().Get("track_id")
        if songID == "" </span><span class="cov0" title="0">{
                resp := lib.Response{
                        StatusCode: http.StatusBadRequest,
                        Message:    "missing {track_id} parameter",
                }
                data, _ := gojson.Marshal(resp)
                http.Error(w, string(data), http.StatusBadRequest)
                return
        }</span>

        // 3)  : like  unlike
        <span class="cov0" title="0">action := "like"
        if r.Method == http.MethodDelete </span><span class="cov0" title="0">{
                action = "unlike"
        }</span>

        // 4)  
        <span class="cov0" title="0">songAction := SongAction{
                Action:  action,
                UserID:  userID,
                TrackID: songID,
        }

        // 5)   JSON  
        rawData, err := gojson.Marshal(songAction)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("gojson marshal", slog.String("error", err.Error()))
                http.Error(w, "server error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">slog.Info("enqueue song action", slog.String("raw data", string(rawData)))

        // 6)    deferred_tasks
        task := models.DefferedTask{
                Topic:     "songs_actions",
                Data:      rawData,
                CreatedAt: time.Now(),
        }
        if err := router.taskService.ActionWithSong(r.Context(), task); err != nil </span><span class="cov0" title="0">{
                slog.Info("actionWithSong handler", slog.String("error", err.Error()))
                resp := lib.Response{
                        StatusCode: http.StatusInternalServerError,
                        Message:    "server error",
                }
                data, _ := gojson.Marshal(resp)
                http.Error(w, string(data), http.StatusInternalServerError)
                return
        }</span>

        // 7)  success
        <span class="cov0" title="0">resp := lib.Response{
                StatusCode: http.StatusOK,
                Message:    "success",
        }
        out, _ := gojson.Marshal(resp)
        w.Write(out)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/adapters/transport/http/userRouter/router.go

// Package mock_userrouter is a generated GoMock package.
package userRouterMocks

import (
        context "context"
        reflect "reflect"
        time "time"

        models "github.com/Cwby333/user-microservice/internal/models"
        gomock "github.com/golang/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov0" title="0">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateTokens mocks base method.
func (m *MockUserService) CreateTokens(ctx context.Context, user models.User) (models.JWTAccess, models.JWTRefresh, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTokens", ctx, user)
        ret0, _ := ret[0].(models.JWTAccess)
        ret1, _ := ret[1].(models.JWTRefresh)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// CreateTokens indicates an expected call of CreateTokens.
func (mr *MockUserServiceMockRecorder) CreateTokens(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTokens", reflect.TypeOf((*MockUserService)(nil).CreateTokens), ctx, user)
}</span>

// DeleteUser mocks base method.
func (m *MockUserService) DeleteUser(ctx context.Context, ID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", ctx, ID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockUserServiceMockRecorder) DeleteUser(ctx, ID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockUserService)(nil).DeleteUser), ctx, ID)
}</span>

// FindUserByID mocks base method.
func (m *MockUserService) FindUserByID(ctx context.Context, ID string) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByID", ctx, ID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByID indicates an expected call of FindUserByID.
func (mr *MockUserServiceMockRecorder) FindUserByID(ctx, ID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByID", reflect.TypeOf((*MockUserService)(nil).FindUserByID), ctx, ID)
}</span>

// GetAllUsers mocks base method.
func (m *MockUserService) GetAllUsers(ctx context.Context) ([]models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx)
        ret0, _ := ret[0].([]models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockUserServiceMockRecorder) GetAllUsers(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockUserService)(nil).GetAllUsers), ctx)
}</span>

// Login mocks base method.
func (m *MockUserService) Login(ctx context.Context, user models.User) (models.JWTAccess, models.JWTRefresh, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Login", ctx, user)
        ret0, _ := ret[0].(models.JWTAccess)
        ret1, _ := ret[1].(models.JWTRefresh)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// Login indicates an expected call of Login.
func (mr *MockUserServiceMockRecorder) Login(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Login", reflect.TypeOf((*MockUserService)(nil).Login), ctx, user)
}</span>

// Logout mocks base method.
func (m *MockUserService) Logout(ctx context.Context, tokenID string, unixTimeExpired time.Time) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Logout", ctx, tokenID, unixTimeExpired)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Logout indicates an expected call of Logout.
func (mr *MockUserServiceMockRecorder) Logout(ctx, tokenID, unixTimeExpired interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logout", reflect.TypeOf((*MockUserService)(nil).Logout), ctx, tokenID, unixTimeExpired)
}</span>

// Register mocks base method.
func (m *MockUserService) Register(ctx context.Context, user models.User) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Register", ctx, user)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Register indicates an expected call of Register.
func (mr *MockUserServiceMockRecorder) Register(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockUserService)(nil).Register), ctx, user)
}</span>

// UpdateUser mocks base method.
func (m *MockUserService) UpdateUser(ctx context.Context, ID string, newUserInfo models.User) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", ctx, ID, newUserInfo)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceMockRecorder) UpdateUser(ctx, ID, newUserInfo interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserService)(nil).UpdateUser), ctx, ID, newUserInfo)
}</span>

// MockDefferedTaskService is a mock of DefferedTaskService interface.
type MockDefferedTaskService struct {
        ctrl     *gomock.Controller
        recorder *MockDefferedTaskServiceMockRecorder
}

// MockDefferedTaskServiceMockRecorder is the mock recorder for MockDefferedTaskService.
type MockDefferedTaskServiceMockRecorder struct {
        mock *MockDefferedTaskService
}

// NewMockDefferedTaskService creates a new mock instance.
func NewMockDefferedTaskService(ctrl *gomock.Controller) *MockDefferedTaskService <span class="cov0" title="0">{
        mock := &amp;MockDefferedTaskService{ctrl: ctrl}
        mock.recorder = &amp;MockDefferedTaskServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDefferedTaskService) EXPECT() *MockDefferedTaskServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ActionWithSong mocks base method.
func (m *MockDefferedTaskService) ActionWithSong(ctx context.Context, task models.DefferedTask) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ActionWithSong", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ActionWithSong indicates an expected call of ActionWithSong.
func (mr *MockDefferedTaskServiceMockRecorder) ActionWithSong(ctx, task interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActionWithSong", reflect.TypeOf((*MockDefferedTaskService)(nil).ActionWithSong), ctx, task)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import (
        "os"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
        "github.com/joho/godotenv"
)

type Config struct {
        Server Server `yaml:"server" env-required:"true"`
        DB     DB     `yaml:"postgres" env-required:"true"`
        JWT    JWT    `yaml:"jwt" env-required:"true"`
        Redis  Redis  `yaml:"redis" env-required:"true"`
}

type Server struct {
        Address         string        `yaml:"address" env-required:"true"`
        IdleTimeout     time.Duration `yaml:"idle-timeout" env-required:"true"`
        ShutdownTimeout time.Duration `yaml:"shutdown-timeout" env-required:"true"`
}

// Postgres(pgxpool)
type DB struct {
        Host     string `yaml:"host" env-required:"true"`
        Port     uint16 `yaml:"port" env-required:"true"`
        User     string `yaml:"user" env-required:"true"`
        Password string `yaml:"password" env-required:"true"`
        DB       string `yaml:"db" env-required:"true"`
        MaxConns int    `yaml:"max-conns" env-required:"true"`
        MinConns int    `yaml:"min-conns" env-required:"true"`
}

type Redis struct {
        Host     string `yaml:"host" env-required:"true"`
        Port     int    `yaml:"port" env-required:"true"`
        Username string `yaml:"username" env-required:"true"`
        Password string `yaml:"password" env-required:"true"`
        DB       int    `yaml:"db"`
}

type JWT struct {
        SecretKey string `yaml:"secret-key" env-required:"true"`
        Issuer    string `yaml:"issuer" env-required:"true"`

        JWTAccess struct {
                Expired time.Duration `yaml:"expired" env-required:"true"`
        } `yaml:"jwt-access" env-required:"true"`

        JWTRefresh struct {
                Expired time.Duration `yaml:"expired" env-required:"true"`
        } `yaml:"jwt-refresh" env-required:"true"`
}

func MustLoad() Config <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var cfg Config
        err = cleanenv.ReadConfig(os.Getenv("CONFIG_PATH"), &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package migrations

import (
        "errors"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

func Migrate(connStr string) error <span class="cov0" title="0">{
        m, err := migrate.New("file://migrations", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/service/userService/service.go

// Package mock_userservice is a generated GoMock package.
package mock_userservice

import (
        context "context"
        reflect "reflect"
        time "time"

        models "github.com/Cwby333/user-microservice/internal/models"
        gomock "github.com/golang/mock/gomock"
)

// MockUserRepo is a mock of UserRepo interface.
type MockUserRepo struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepoMockRecorder
}

// MockUserRepoMockRecorder is the mock recorder for MockUserRepo.
type MockUserRepoMockRecorder struct {
        mock *MockUserRepo
}

// NewMockUserRepo creates a new mock instance.
func NewMockUserRepo(ctrl *gomock.Controller) *MockUserRepo <span class="cov0" title="0">{
        mock := &amp;MockUserRepo{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepo) EXPECT() *MockUserRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserRepo) CreateUser(ctx context.Context, user models.User) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", ctx, user)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserRepoMockRecorder) CreateUser(ctx, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserRepo)(nil).CreateUser), ctx, user)
}</span>

// DeleteUserByID mocks base method.
func (m *MockUserRepo) DeleteUserByID(ctx context.Context, ID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUserByID", ctx, ID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUserByID indicates an expected call of DeleteUserByID.
func (mr *MockUserRepoMockRecorder) DeleteUserByID(ctx, ID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUserByID", reflect.TypeOf((*MockUserRepo)(nil).DeleteUserByID), ctx, ID)
}</span>

// GetAllUsers mocks base method.
func (m *MockUserRepo) GetAllUsers(ctx context.Context) ([]models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllUsers", ctx)
        ret0, _ := ret[0].([]models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllUsers indicates an expected call of GetAllUsers.
func (mr *MockUserRepoMockRecorder) GetAllUsers(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllUsers", reflect.TypeOf((*MockUserRepo)(nil).GetAllUsers), ctx)
}</span>

// GetUserByID mocks base method.
func (m *MockUserRepo) GetUserByID(ctx context.Context, ID string) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByID", ctx, ID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByID indicates an expected call of GetUserByID.
func (mr *MockUserRepoMockRecorder) GetUserByID(ctx, ID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByID", reflect.TypeOf((*MockUserRepo)(nil).GetUserByID), ctx, ID)
}</span>

// GetUserByUsername mocks base method.
func (m *MockUserRepo) GetUserByUsername(ctx context.Context, username string) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUserByUsername", ctx, username)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUserByUsername indicates an expected call of GetUserByUsername.
func (mr *MockUserRepoMockRecorder) GetUserByUsername(ctx, username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByUsername", reflect.TypeOf((*MockUserRepo)(nil).GetUserByUsername), ctx, username)
}</span>

// UpdateUserByID mocks base method.
func (m *MockUserRepo) UpdateUserByID(ctx context.Context, ID string, newUserInfo models.User) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUserByID", ctx, ID, newUserInfo)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateUserByID indicates an expected call of UpdateUserByID.
func (mr *MockUserRepoMockRecorder) UpdateUserByID(ctx, ID, newUserInfo interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUserByID", reflect.TypeOf((*MockUserRepo)(nil).UpdateUserByID), ctx, ID, newUserInfo)
}</span>

// MockDefferedTaksRepo is a mock of DefferedTaksRepo interface.
type MockDefferedTaksRepo struct {
        ctrl     *gomock.Controller
        recorder *MockDefferedTaksRepoMockRecorder
}

// MockDefferedTaksRepoMockRecorder is the mock recorder for MockDefferedTaksRepo.
type MockDefferedTaksRepoMockRecorder struct {
        mock *MockDefferedTaksRepo
}

// NewMockDefferedTaksRepo creates a new mock instance.
func NewMockDefferedTaksRepo(ctrl *gomock.Controller) *MockDefferedTaksRepo <span class="cov0" title="0">{
        mock := &amp;MockDefferedTaksRepo{ctrl: ctrl}
        mock.recorder = &amp;MockDefferedTaksRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDefferedTaksRepo) EXPECT() *MockDefferedTaksRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockDefferedTaksRepo) Create(ctx context.Context, task models.DefferedTask) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, task)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockDefferedTaksRepoMockRecorder) Create(ctx, task interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockDefferedTaksRepo)(nil).Create), ctx, task)
}</span>

// MockRefreshInvalidator is a mock of RefreshInvalidator interface.
type MockRefreshInvalidator struct {
        ctrl     *gomock.Controller
        recorder *MockRefreshInvalidatorMockRecorder
}

// MockRefreshInvalidatorMockRecorder is the mock recorder for MockRefreshInvalidator.
type MockRefreshInvalidatorMockRecorder struct {
        mock *MockRefreshInvalidator
}

// NewMockRefreshInvalidator creates a new mock instance.
func NewMockRefreshInvalidator(ctrl *gomock.Controller) *MockRefreshInvalidator <span class="cov0" title="0">{
        mock := &amp;MockRefreshInvalidator{ctrl: ctrl}
        mock.recorder = &amp;MockRefreshInvalidatorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRefreshInvalidator) EXPECT() *MockRefreshInvalidatorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// InvalidRefresh mocks base method.
func (m *MockRefreshInvalidator) InvalidRefresh(arg0 context.Context, arg1 string, arg2 time.Time) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InvalidRefresh", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// InvalidRefresh indicates an expected call of InvalidRefresh.
func (mr *MockRefreshInvalidatorMockRecorder) InvalidRefresh(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidRefresh", reflect.TypeOf((*MockRefreshInvalidator)(nil).InvalidRefresh), arg0, arg1, arg2)
}</span>

// MockUserCache is a mock of UserCache interface.
type MockUserCache struct {
        ctrl     *gomock.Controller
        recorder *MockUserCacheMockRecorder
}

// MockUserCacheMockRecorder is the mock recorder for MockUserCache.
type MockUserCacheMockRecorder struct {
        mock *MockUserCache
}

// NewMockUserCache creates a new mock instance.
func NewMockUserCache(ctrl *gomock.Controller) *MockUserCache <span class="cov0" title="0">{
        mock := &amp;MockUserCache{ctrl: ctrl}
        mock.recorder = &amp;MockUserCacheMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserCache) EXPECT() *MockUserCacheMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockUserCache) Delete(ctx context.Context, userID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, userID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserCacheMockRecorder) Delete(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserCache)(nil).Delete), ctx, userID)
}</span>

// Get mocks base method.
func (m *MockUserCache) Get(ctx context.Context, userID string) (models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, userID)
        ret0, _ := ret[0].(models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockUserCacheMockRecorder) Get(ctx, userID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockUserCache)(nil).Get), ctx, userID)
}</span>

// Set mocks base method.
func (m *MockUserCache) Set(ctx context.Context, usersID string, user models.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", ctx, usersID, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockUserCacheMockRecorder) Set(ctx, usersID, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockUserCache)(nil).Set), ctx, usersID, user)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package userservice

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"
        "unicode/utf8"

        allerrors "github.com/Cwby333/user-microservice/internal/allErrors"
        "github.com/Cwby333/user-microservice/internal/models"
        "github.com/google/uuid"

        "golang.org/x/crypto/bcrypt"
)

type UserRepo interface {
        CreateUser(ctx context.Context, user models.User) (models.User, error)

        GetUserByID(ctx context.Context, ID string) (models.User, error)
        GetUserByUsername(ctx context.Context, username string) (models.User, error)
        GetAllUsers(ctx context.Context) ([]models.User, error)

        DeleteUserByID(ctx context.Context, ID string) error

        UpdateUserByID(ctx context.Context, ID string, newUserInfo models.User) (models.User, error)
}

type DefferedTaksRepo interface {
        Create(ctx context.Context, task models.DefferedTask) error
}

type RefreshInvalidator interface {
        InvalidRefresh(ctx context.Context, tokenID string, expired time.Time) error
}

type UserCache interface {
        Set(ctx context.Context, usersID string, user models.User) error
        Get(ctx context.Context, userID string) (models.User, error)
        Delete(ctx context.Context, userID string) error
}

type JWTConfig struct {
        SecretKey      string
        Issuer         string
        AccessExpired  time.Duration
        RefreshExpired time.Duration
}

type Service struct {
        userRepo         UserRepo
        defferedTaskRepo DefferedTaksRepo
        invalidator      RefreshInvalidator
        userCache        UserCache
        config           JWTConfig
}

func New(userRepo UserRepo, taskRepo DefferedTaksRepo, userCache UserCache, invalidator RefreshInvalidator, cfg JWTConfig) Service <span class="cov8" title="1">{
        return Service{
                userRepo:         userRepo,
                defferedTaskRepo: taskRepo,
                invalidator:      invalidator,
                userCache:        userCache,
                config:           cfg,
        }
}</span>

func (s Service) Register(ctx context.Context, user models.User) (models.User, error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.Register.go"

        if utf8.RuneCountInString(user.Password) &lt; 8 </span><span class="cov8" title="1">{
                return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrPasswordSmall)
        }</span>
        <span class="cov8" title="1">if utf8.RuneCountInString(user.Password) &gt; 72 </span><span class="cov8" title="1">{
                return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrPasswordBig)
        }</span>

        <span class="cov8" title="1">psw, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">user.Password = string(psw)
        if user.Role == "" </span><span class="cov8" title="1">{
                user.Role = "user"
        }</span>

        <span class="cov8" title="1">user, err = s.userRepo.CreateUser(ctx, user)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (s Service) Login(ctx context.Context, user models.User) (access models.JWTAccess, refresh models.JWTRefresh, err error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.Login"

        userFromRepo, err := s.userRepo.GetUserByUsername(ctx, user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return models.JWTAccess{}, models.JWTRefresh{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(userFromRepo.Password), []byte(user.Password))
        if err != nil </span><span class="cov8" title="1">{
                return models.JWTAccess{}, models.JWTRefresh{}, fmt.Errorf("%s: %w", op, allerrors.ErrWrongPass)
        }</span>

        <span class="cov8" title="1">user.ID = userFromRepo.ID
        access, refresh, err = s.CreateTokens(ctx, user)
        if err != nil &amp;&amp; userFromRepo.Password != user.Password </span><span class="cov0" title="0">{
                return models.JWTAccess{}, models.JWTRefresh{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return access, refresh, nil</span>
}

func (s Service) Logout(ctx context.Context, tokenID string, tokenExpiredUnix time.Time) error <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.Logout"

        err := s.invalidator.InvalidRefresh(ctx, tokenID, tokenExpiredUnix)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s Service) FindUserByID(ctx context.Context, ID string) (models.User, error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.FindUserByID"

        if err := uuid.Validate(ID); err != nil </span><span class="cov8" title="1">{
                return models.User{}, fmt.Errorf("%s: %w", op, allerrors.ErrWrongUUID)
        }</span>

        <span class="cov8" title="1">user, err := s.userCache.Get(ctx, ID)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                slog.Info("user cache hit", slog.String("userID", ID))
                
                return user, nil</span>
        default:<span class="cov0" title="0">
                if errors.Is(err, allerrors.ErrNotFoundInCache) </span><span class="cov0" title="0">{
                        slog.Info("user cache miss", slog.String("userID", ID))
                        break</span>
                }

                <span class="cov0" title="0">slog.Info("user cache", slog.String("error", err.Error()))</span>        
        }

        <span class="cov0" title="0">user, err = s.userRepo.GetUserByID(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov0" title="0">err = s.userCache.Set(ctx, ID, user)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("user cache", slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">return user, err</span>
}

func (s Service) GetAllUsers(ctx context.Context) ([]models.User, error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.GetAllUsers"

        slice, err := s.userRepo.GetAllUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return slice, nil</span>
}

func (s Service) DeleteUser(ctx context.Context, ID string) error <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.GetAllUsers"

        if err := uuid.Validate(ID); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s: %w", op, allerrors.ErrWrongUUID)
        }</span>

        <span class="cov8" title="1">err := s.userRepo.DeleteUserByID(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = s.userCache.Delete(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("cache", slog.String("error", err.Error()))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s Service) UpdateUser(ctx context.Context, ID string, newUserInfo models.User) (models.User, error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.UpdateUser"
                
        user, err := s.userRepo.GetUserByID(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">if newUserInfo.Email == "" </span><span class="cov0" title="0">{
                newUserInfo.Email = user.Email
        }</span>
        <span class="cov8" title="1">if newUserInfo.Username == "" </span><span class="cov8" title="1">{
                newUserInfo.Username = user.Username
        }</span>
        <span class="cov8" title="1">newUserInfo.Role = user.Role

        switch newUserInfo.Password </span>{
        case "":<span class="cov8" title="1">
                newUserInfo.Password = user.Password</span>
        default:<span class="cov8" title="1">
                psw, err := bcrypt.GenerateFromPassword([]byte(newUserInfo.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return models.User{}, fmt.Errorf("%s: %w", op, err)
                }</span>

                <span class="cov8" title="1">newUserInfo.Password = string(psw)</span>
        }

        <span class="cov8" title="1">user, err = s.userRepo.UpdateUserByID(ctx, ID, newUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">err = s.userCache.Set(ctx, ID, newUserInfo)
        if err != nil </span><span class="cov0" title="0">{
                slog.Info("cache", slog.String("error", err.Error()))
        }</span>

        <span class="cov8" title="1">return user, err</span>
}

func (s Service) ActionWithSong(ctx context.Context, task models.DefferedTask) error <span class="cov8" title="1">{
        const op = "./internal/service/userService/service.go.LikeSong"

        err := s.defferedTaskRepo.Create(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package userservice

import (
        "context"
        "fmt"
        "time"

        "github.com/Cwby333/user-microservice/internal/models"
        "github.com/google/uuid"

        "github.com/golang-jwt/jwt/v5"
)

func (s Service) CreateTokens(ctx context.Context, user models.User) (access models.JWTAccess, refresh models.JWTRefresh, err error) <span class="cov8" title="1">{
        const op = "./internal/service/userService/tokens.go.createTokens"

        accessToken := jwt.NewWithClaims(jwt.SigningMethodHS256, models.JWTAccess{
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    s.config.Issuer,
                        Subject:   user.ID,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(s.config.AccessExpired)),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ID:        uuid.NewString(),
                },
                Type: "access",
                Role: user.Role,
        })

        accessSign, err := accessToken.SignedString([]byte(s.config.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return models.JWTAccess{}, models.JWTRefresh{}, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov8" title="1">access = accessToken.Claims.(models.JWTAccess)
        access.Sign = accessSign
        access.Type = "access"

        refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, models.JWTRefresh{
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    s.config.Issuer,
                        Subject:   user.ID,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(s.config.RefreshExpired)),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ID:        uuid.NewString(),
                },
                Type: "refresh",
                Role: user.Role,
        })
        refreshSign, err := refreshToken.SignedString([]byte(s.config.SecretKey))

        if err != nil </span><span class="cov0" title="0">{
                return models.JWTAccess{}, models.JWTRefresh{}, fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov8" title="1">refresh = refreshToken.Claims.(models.JWTRefresh)
        refresh.Sign = refreshSign
        refresh.Type = "refresh"

        return access, refresh, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
