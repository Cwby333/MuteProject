Основное ответ о результате выполнения запроса:  
MainResponse:  
{  
    "message": "сообщение о результате выполнения запроса"  
    "status": "http статус код",  
}  

POST /user/register - регистрация пользователя  
Запрос:  
{  
    "username": "имя пользователя",  
    "password": "пароль",           #Не меньше 8 символов  
    "email": "электронная почта",  
}  
Ответ(успех):  
{  
    "response": {  
        "message": "success login",  
        "status": 200  
    },  
    "username": "",  
    "email": "",  
    "id": "ID зарегистрированного пользователя",  
}  

POST /user/login - аутентификация пользователя  
Запрос:  
{  
    "username": "имя пользователя",    
    "password": "пароль"  
}  
Ответ (успех):  
{  
    "response": {  
        "message": "success login",  
        "status": 200  
    },  
    "token": "JWT-токен доступа",  
    "id": "ID пользователя"  
}  
Возможные ошибки:  
400 - неверный формат запроса  
401 - неверный логин/пароль  
404 - пользователь не найден  
500 - внутренняя ошибка сервера  

POST /user/logout - выход из системы  
Требует: JWT-токен в куках  
Ответ (успех):  
{  
    "message": "success",  
    "status": 200  
}  
Ошибки:  
401 - неавторизованный запрос  
500 - ошибка сервера  

POST /user/refresh - обновление токенов  
Требует: Refresh-токен в куках  
Ответ (успех):  
{  
    "message": "success",  
    "status": 200  
}  
(Новые токены устанавливаются в cookies)  

GET /user/get - получение информации о пользователе  
Требует: JWT-токен  
Ответ (успех):  
{  
    "response": {  
        "message": "success",  
        "status": 200  
    },  
    "username": "имя пользователя",  
    "id": "ID пользователя"  
}  

PUT /user/update - обновление данных пользователя
Требует: JWT-токен
Запрос:
{
    "username": "новое имя",  // Опционально
    "email": "новая почта",   // Опционально
    "password": "новый пароль" // Опционально
}
Ответ (успех):
{
    "response": {
        "message": "success",
        "status": 200
    },
    "username": "обновленное имя",
    "email": "обновленная почта",
    "id": "ID пользователя"
}

DELETE /user/delete - удаление пользователя
Требует: JWT-токен
Ответ (успех):
{
    "message": "success",
    "status": 200
}
Возможные ошибки:
500 - ошибка сервера

POST /user/track/favorite - добавление трека в избранное  
Требует: JWT-токен + параметр track_id  
Ответ (успех):  
{  
    "message": "success",  
    "status": 200  
}  
Возможные ошибки:  
401 - неавторизованный запрос 
500 - ошибка сервера  
  
DELETE /user/track/favorite - удаление трека из избранного  
Требует: JWT-токен + параметр track_id в запросе  
  
Ответ (успех):  
{  
    "message": "success",  
    "status": 200  
}  
Возможные ошибки:  
401 - неавторизованный запрос  
500 - ошибка сервера  
  
Общие замечания:  
Все ошибки возвращаются в формате:  
  
{  
    "message": "описание ошибки",  
    "status": "код ошибки"  
}  
Для авторизованных endpoints:  
  
Требуют валидный JWT в заголовке Authorization  
  
При ошибке 401 - токен невалиден/просрочен  
  
403 - нет прав доступа  

Основная логика endpoint'ов:  
POST /user/register:  
Прием запроса, валидация его, передача пользователя дальше, в серсиве основная валидация, передача в слой репозитория, в hadnler'е проверяем возвращаемую ошибку, в зависимости от ошибки формируем ответ  
  
POST /user/login:  
Прием запроса, валидация его, передача пользователя дальше, передача в слой репозитория, в случае nil ошибки проверяем хешированный пароль из БД с введенным паролем, в hadnler'е проверяем возвращаемую ошибку, в зависимости от ошибки формируем ответ  
  
POST /user/logout:  
Прием запроса, зануление cookie  
  
POST /user/refresh:  
Прием запроса, в middleware jwt проверяется refresh-token, выдача новых токенов  
  
GET /user/get:  
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims в hadnler'e берем ID user'a, по этому ID ищем user'a, проверяем возвразаемую ошибку, формируем ответ  
  
GET /user/all:  
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims берем role пользователя, если admin - выбираем всех пользователей из баззы и отдаем, иначе запрос не авторизован  
  
DELETE /user/delete:  
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims в hadnler'e берем ID user'a, по этому ID удаляем user'a, проверяем возвразаемую ошибку, формируем ответ  

PUT /user/update:
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims в hadnler'e берем ID user'a, по этому ID обновляем user'a, проверяем возвразаемую ошибку, формируем ответ  
  
POST /user/track/favorite:  
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims в hadnler'e берем ID user'a, из пути запроса берем track_id и используем userID с track_id для создания записи в таблицу deffered_tasks, проверяем возвразаемую ошибку, формируем ответ  

DELETE /user/track/favorite:
Прием запроса, в middleware проверяется access-token, извлеченные claims передаются в контексте запроса, из claims в hadnler'e берем ID user'a, из пути запроса берем track_id и используем userID с track_id для создания записи в таблицу deffered_tasks, проверяем возвразаемую ошибку, формируем ответ  
